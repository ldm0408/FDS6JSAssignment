
##Built-in method / property / object
자바스크립트는 내장 된 기능이 있다
내장 된 기능과 유사한 기능을 구현하려하면 시간 낭비 돈낭비 심지어 성능도 떨어진다
 - 그러한 이유로 내장 기능을 숙지 하고 있어야 한다
자바스크립트는 빌트인이 다른언어 보다 적은편이다

*Built-in === API

*String과 Array 중요하다
*Array: 순서가 있고, for문에서 순회가능,  다루기 편함 array의 built-in기능이 우수하다


## Built-in Object  내장 객체
BOM 브라우저를 컨틀롤 한다
DOM HTML CSS를 컨트롤해서 페이지를 동적으로 만들어 준다

##Standard Built-in Object
-표준 빌트인 객체 / 네이티브 객체를 제외 한 것
-일반적으로 대문자로 시작한다 / String, Array
-Global Objects 라고도 한다 ( Global Object 와 다르다)


##Standard Built-in Object 표준 빌트인 객체
- 브라우저에서는 window / node에선 global
- 전역 변수와 전역함수는 window의 프로퍼티이다

## 전역 프로퍼티
- 어플리케이션 전역에서 사용하는 값
1) Infinity
- 음,양의 무한대
2) NaN
- Not - a - Number 숫자가 아님
3) undefined

## 전역 함수 / 전역 메소드
1) eval()
- 인자로 들어온 값을 평가 또는 실행한다 - 보안에 매우 취약한 관계로 절대로 사용해선 안된다.

2) isFinite ()    * 프로퍼티명에 is가 들어가면 boolean을 의미한다
- 인자 전달 값이 유한수인지 검사한다. 
- 유한수일 경우 true

3) isNaN()
- 인자 전달 값이 NaN 인지 검사

4) parseFloat()
- 매개변수에 전달된 문자열을 부동소수점 숫자로 변환하여 반환한다.

5) parseInt()
- 매개변수에 문자열을 정수형 숫자로 변환하여 반환한다
- 사용빈도 매우 높다
- 문자를열 숫자로  바꿀 시 사용
* parseInt( 필수 인자,[ 옵션])

6) encodeURI() /decodeURI()
- d

##Standard Built-in Object 표준 빌트인 객체


## 기본자료형과 래퍼객체(wrapper Object)
기본자료형을 객체처럼 사용하기 위해 각가의 기본자료형은 래퍼 객체를 갖고있다.


## 기본 자료형 string을 위한 레퍼(wrapper) 객체
스트링은 유사배열 객체이다.
유사배열 객체는 length 프로퍼티를 갖고 있다. 
스트링 객체는 String() 생성자 함수를 통해 생성할 수 있다.
New String(str);

1)String.length
- 문자열 내의 문자 갯수를 반환한다.

2)String.porototype.charAt()
- 매개변수로 전달한 index 번호에 해당하는 위치의 문자를 반환
- 번호는 0~ (문자열 길이-1) 사이의 정수
- 번호가 0 ~  (문자열 길이-1) 를 벗어난 경우 빈문자열 반환

3)String.prototype.indexOf()
- 매개변수로 전달된 문자 또는 문자열을 대상 문자열에서 검색하여 발견된 곳의 index 반환

4)String.prototype.lastIndexOf()
- 위 와 동일하게 움직이지만 마지막 글자 위치 부터 찾아 낸다.
- 검색시 시작 지점의 index 번호가 0이 되어 역순으로 0,1,2,3....이 되는건아니다
기존 인덱스 번호를 찾아낸다. 검색 방향만 역순

5)String.prototype.replace() *** 매우 중요
첫번쨰 인자를 검색해서 두번째 인자 문자열로 대체한다
스트링 객체의 메소드는 절대 원본을 건드리지 않는다.

6)String.prototype.split() ***매우 중요
매개변수에 따라 문자열이 분리되어 반환된다
배열을 리턴으로 받는다

7)String.prototype.substring() ***** 매우중요요
첫째 인자 인덱스 번호 부터 두번째 인자 인덱스 번호의 문자까지를 모두 반환한다.

8)String.prototype.toLowerCase()*****
문자열의 문자를 모두 소문자로 변경한다.

9)String.prototype.toUpperCase()*****
문자열의 문자를 모두 대문자로 변경한다.

10)String.prototype.trim()
문자열 양쪽 끝에 있는 공백 문자를 제거한 문자열을 반환한다.



## Number Property

1) Number.EPSILON *** 잘 알아두고 있어야함 컴공 기본 소양 ***
한 숫자와 다른 숫자 사이에서 자바스크립트가 표현할 수 있는 가장 작은 수
*소수 표현이 우리가 아는것과 다르다. 약간의 차이가 있다
Ex) 0.1 + 0.2 = 0.30000000000000004 
이에 사소한 오차가 크게 작용되는 분야에서는 라이브러리를 사용해서 이런 오차를 없앤다.
또는 절대값을 반환 하는 Math.abs를 사용해서 Number.EPSILON 보다 작으면 같은수로 인정 할 수 있다.

2) Number.MAX_VALUE * 프로퍼티가 대문자인것은 상수라는 의미(값이 변하지않음)

##Number Method

1) Number.isFinite()
매개변수에 전달된 값이 정상적인 유한수인지 검사
*전역객체의 isFinite() 는 형 변화를 하지만 Number.isFinite() 형변화 안해서 더욱 엄격하다

2) Number.isInteger
정수인지 확인해서 Boolean 값 반환

3) Number.isNaN()
이 또한 형변화 없이 NaN인지 검사한다

4) Number.isSafeInteger()
자바스크립트내에서 사용가능한 정수인지 확인한다.
Number.isSafeInteger(1000000000000000)  // true
Number.isSafeInteger(10000000000000001) // false

1)  ~  4)까지는 객체 생성을 해서 사용하지 않는 스테틱 메소드이다

5) Number.prototype.toExpontial()
대상을 지수 표기법으로 변환하여 문자열로 반환한다. 
- 메소드 사용시 기본적으로 변수에 담아쓰기를 권장

6) Number.prototype.Fixed()
매개변수로 지정된 소숫점자리를 반올림하여 문자열로 반환
- 내가 바라는 숫자 표현방식에 맞게 표현하려 할 때 사용

7) Number.prototype.toPrecision()

8)Number.prototype.toString()
숫자를 문자열로 변환하여 반환
인자값은 ‘진법’을 나타낸다 2 = 2진법 / 10은 10진법

9) Number.prototype.valueOf()
Number 객체의 기본자료형 값을 반환한다.




##MATH 객체
- Math 는 생성자가없는 정적(static)프로퍼티와 메소드이다.

## Math Property
1) Math.PI
파이 값 반환  3.14

## Math Method

1) Math.abs()
 양수 절대값 반환

2)Math.round()
숫자를 가장 인접한 정수로 올림/내림 한다.

3)Math.sqrt()
양의 제곱근 반환

4)Math.ceil()
지정된 숫자를 올림한다

5)Math.floor()
지정된 숫자를 내림한다

6) Math.random()
0~1사이의 임의 숫자를 반환한다 * 0은 포함하지만 1은 포함하지 않는다

7) Math.pow()
첫번쨰 인수를 밑 두번쨰 인수를 지수로 하여 거듭제곱 반환

8)Math.max() ***
인수 중 가장 큰 수를 반환한다
Math.max(1, 2, 3) ;  // 3

*배열을 이용할 경우
var arr = [1, 2, 3];
var max = Math.max.apply(null, arr); // 3
apply는 함수를 호출해준다 이떄 두번째인자는 배열이되고 값을 전달할때 배열안의 값을 풀어서 전달한다. 이때 첫번쨰 인자에 null을 넣어줘야한다. *max는 스태틱이라서 this가 없기 때문이다

9) Math.min()***
인수 중 가장 작은 수를 반환한다




##정규 표현식(Requlat Expressin)
자바스크립트  문법이 아닌 하나의 언어이다.

문자열을 다룬다. 

1) 플래그
i : ignore case - 대소문자를 구별하지 않고 검색
g: global - 문자열 내의 모든 패턴을 검색한다
m: Multi line - 문자열의 행이 바뀌더라도 검색을 계속한다/( 줄 바꿈 무시 )
플래그는 옵션일 뿐 필수 요소는 아니다 필요할 때 사용하자


2) 패턴
패턴은 찾고자 하는 대상을 문자열로 지정한다.
또한 특별한 의미를 가지는 메타문자 또는 기호로 표현 가능하다

.은 임의의 문자 한개를 의미
/. . ./ 은 3개의 문자 추출



##Array 배열******

1개의 변수에 여러 개의 값을 순차적으로 저장할 때 사용한다.
(객체는 순서가 보장되지 않는다)

##배열 리터럴
[] 대괄호로 묶어서 생성한다.
 var arr = [] ; —> 빈배열
배열에 들어가는 값은 요소(element)라고 하고 이는 순서가 있다.
자바스크립트는 배열안의 자료형식 각각 달라도 무방하다

배열 요소의 추가
배열도 생성 이후 동적으로 요소 추가 가능하다
var arr = [];
위 상황에서 아래 와 같이 하면 요소가 추가 된다
arr[0] = ‘one’;
arr[1] = ’two;

1)  Array.length
요소의 갯수를 나타냄

## Array Method

1) Array.isArray()
객체가 배열이면 true 아니면 false

2) Array.prototype.indexOf()
인자로 지정된 요소를 배열에서 검색하여 인덱스를 반환한다.

3)Array.prototype.concat(item…)
인수로 넘어온 값 또는 배열을 자신의 복사본에 요소로 추가하고 반환한다.
var c = a.concat(b);
console.log(c); // ['a', 'b', 'c', 'x', 'y', 'z']
위와 같은 경우 배열 자체를 추가하는것이 아닌 해당 배열 안 요소들을 추가한다.
* 원본 배열은 변경 되지 않는다.

4)Array.prototype.join()
배열요소 전체를 연결하여 문자열을 반환한다.

5) Array.prototype.pop()
배열 마지막 요소를 제거하고 제거한 요소를 반환한다.
* 원본 배열이 변경된다.

6) Array.prototype.push()
인자로 전달한 항목을 배열의 끝에 추가한다.
인자가 배열인 경우 배열 자체를 추가 한다.

7) Array.prototype.reverse()
배열 요소의 순서를 반대로 변경한다. 이때 원본 배열이 변경 된다
반환값은 변경된 배열이다

8)Array.prototype.shift()
배열에서 첫요소를 제거하고 제거한 요소를 반환한다. 만약 빈 배열일 경우 undefined를 반환한다.

9)Array.prototype.slice(start, end) *****
배열의 특정 부분에 대한 복사본 생성

10)Array.prototype.splice(start, deleteCount, item...)*****
첫째 인자 부터 2번째 인자 개수의 요소를 제거 후 제거된 요소를 배열로 반환

3번째 인자 부터는 새롭게 추가할 요소가 된다.

11) Array.prototype.sort**
배열의 내용을 정렬한다


12) Array.prototype.forEach ***************
For 문의 일종이다
for문을 따로 쓰지 않아도 순회하면서 지정
function( item , index, array)

13) Array.prototype.map() *****************
원본 배열의 값을 이용하여 새로운 배열을 생성 할 시 사용한다
원본 배열에 매소드를 사용하고 그 결과값을 리턴하면 새로운 배열 생성된다.
리턴을 하지 않으면 새로운 배열에 반영되지 않는다.
 


# 실행 컨텍스트와 자바스크립트의 동작 원리
  * 잘 알면 디버깅을 잘 할 수 있다.
## 실행 컨텍스트
  * 실행 가능한 코드를 형상화하고 구분하는 추상적 개념(ECMAScript)
    * 실행 가능한 코드: 전역코드와 함수코드(Eval함수 코드는 사용 금지)
  * 코드 실행을 위한 정보
    * 변수: 전역변수, 지역변수, 매개변수, 객체의 프로퍼티.
    * 함수 선언: 함수명(무명함수 제외)과 함수 자체  
    * 변수의 유효범위(Scope)
    * this: 이 this가 가리키는 것이 무엇인가?
 * 실행 컨텍스트 스택(콜 스택)과 코드 실행 순서
   * 실행 컨텍스트(EC)가 쌓이는 메모리상의 공간
   * 전전 실행 컨텍스트는 브라우저를 종료할 때까지 계속 메모리 공간 점유

## 실행 컨텍스트의 3가지 객체
  1. Variable Object(변수객체)
  * 변수, 매개변수(parameter), 인수정보(arguments), 함수선언(변수로 취급되는 함수표현식은 제외)을 담고 있음.
  * 전역 컨텍스트에서 VO는 전역객체(GO/ window, global)를 가르키며 그 안에 세팅해 놓는다. (전역 객체는 전역 컨텍스트 이전인, 브라우저를 켜는 순간 태초부터 존재했다.)
    * 전역 변수는 왜 전역 객체의 프로퍼티인가에 대한 이야기
    * 함수 컨텍스트에서 VO는 활성객체(AO, Activation Object)를 가리킨다.

  2. Scope Chain
  * 다이렉트로 가리키는게 아니다. 스코프가 여러 개가 있을 수 있기 때문에 배열처럼 리스트화된 단계를 거친다. 순서가 있어서 0인 자신의 AO를 보고 그래도 없으면 두번째인 1, 상위(본 예제에서는 전역)인 GO를 본다.
   * 즉, 그 중간 단계는 스코프 판단을 위한 단계

  3. this value
  * this 프로퍼티에는 this 값이 할당된다. this에 할당되는 값은 함수 호출 패턴에 의해 결정된다.

## 실행 컨텍스트의 생성 과정
  ```javascript
  // 판단 예제

  var x = 'xxx';

  function foo () {
    var y = 'yyy';

    function bar () {
      var z = 'zzz';
      console.log(x + y + z);
    }
    bar();
  }
  foo();
  ```
  
  * 전역 코드에의 진입
    * 이 상태는 전역 코드 실행 전 단계
    * 초기 상태의 전역객체는 빌트인 객체와 BOM, DOM 등이 있다.
    1. 스코프 체인의 생성과 초기화
    2. Variable Instantiation(변수 객체화) 실행
        1. 함수 foo의 선언 처리 : 함수 호이스팅의 원리(scope판단을 위해 이미 함수의 내용을 다 갖고 있음)
        2.  변수 x의 선언 처리 : 변수 호이스팅의 원리(선언, 초기화만 수행)
    3. this value 결정

  * 전역 코드의 실행
    1. 변수 값의 할당 : 전역변수 x에 문자열 ‘xxx’를 할당
    2. 함수 foo의 실행 : `전역 코드에의 진입`의 경우와 마찬가지로 다음 3단계 거침
        1. 스코프 체인의 생성과 초기화
        2. Variable Instantiation 실행
        3.  this value 결정

  * foo 함수 코드의 실행
    * `전역 코드의 실행`과 마찬가지 과정을 반복한다.
    1. 변수 값의 할당: 지역변수 y에 문자열 'yyy'를 할당
    2. 함수 bar의 실행: 이 단계에서 `console.log(x + y + z);`의 실행 결과는 xxxyyyzzz가 된다.


# 클로저 - Closure

##클로저의 개념
자바스크립트에서 중요한 개념. 
*일급객체 : 객체를 값 처럼 사용 가능
일급 객체를 취급하는 함수형 언어에서 사용 된다.
내부함수가 참조하는 외부함수의 지역변수가 외부함수에 의해 내부함수가 반환된 이후에도 life-cycle이 유지되는 것을 의미. 이때의 변수는 자유변수이다.
 - 즉 내부함수는 외부함수를 참조 할 수 있다.
 - 내부함수의 스코프는 외부함수의 스코프를 참조할수 있다.


##클로저 전제 조건
 외부함수 와 내부함수로 이뤄져 있고 내부함수는 외부함수를 참조한다

## 클로저 단점
무분별한 클로저의 사용은 득보다는 실이 많다. 클로저 작동이 종료가 되어도 외부함수 의 VO가 메모리에 남아있게 되어 많이 사용하면 해당 건이 누적되어 성능이 떨어지게 된다. 

## 예제
아래의 링크를 통해 클로저 예제를 공부해보자
[예제 링크](http://poiemaweb.com/js-closure#2-클로저의-활용)

# 자바스크립트 객체 지향 프로그래밍
객체지향 프로그래밍은 실세계에 존재하고 인지하고 있는 객체(Object)를 소프트웨어의 세계에서 표현하기 위해 객체의 핵심적인 개념 또는 기능만을 추출하는 추상화(abstraction)를 통해 모델링하려는 프로그래밍 패러다임을 말한다

객체지향 프로그래밍은 함수들의 집합 혹은 단순한 컴퓨터의 명령어들의 목록이라는 전통적인 절차지향 프로그래밍과는 다른, 관계성있는 객체들의 집합이라는 관점으로 접근하는 소프트웨어 디자인으로 볼 수 있다.

## 클래스 기반 언어
1.클래스란 같은 종류의 집단에 속하는 속성과 행위를 정의한것이다.
2.객체 생성에 사용되는 패턴이기에 반드시 new연산자를 통한 인스턴스화 과정필요.
3.모든 인스턴스는 클래스에서 정의된 범위 내에서만 작동 가능, 런타임에 그 구조 변경 불가
 - 이는 프로토타입기반 언어보다 좀 더 나은 결과를 보장함

## 프로토타입 기반 언어
1. 자바스크립트는 별도의 객체 생성 방법이 존재함
2. 생성된 인스턴스의 자료구조와 기능을 동적 변경 가능.
3. 상속, 캡슐화등은 프로토타입 체인과 클로저 등으로 구현 가능.

## 상속
- 자바스크립트는 프로토타입을 통해 객체가 다른 객체로 직접 상속 구현.
### 의사 클래스 패턴 상속
- 자식 생성자 함수의 prototype 프로퍼티를 부모 생성자 함수의 인스턴스로 교체하여 구현하는 방법
- 문제점
 1) new연산자를 통해 인스턴스를 생성하는 불필요한 단계 존재
 2) 생성자 링크의 파괴 상속 받은 인스턴스는 constructor와의 연결이 꺠지게 된다
 3) 객체 리터럴 패턴에 의한 객체에는 부적합

### 프로토타입 패턴 상속
-  Object.create 함수를 사용하여 객체에서 다른 객체로 직접 상속을 구현하는 방식이다. 의사 클래스 패턴 상속의 문제점을 보완함.


* 자바스크립트는 클래스 기반 언어가 아니므로 기존의 전통적 방식으로 구현하려는 시도는 당시 상황에 최선의 노력이었다. 하지만 현재는 자바스크립트 언어에 매우 효과적인 프레임 워크가 있으니 이를 충분히 활용하고, 자바스크립트만의 방식을 잘 활용하여 보다 효율적인 프로그래밍을 추구해야한다. 

































